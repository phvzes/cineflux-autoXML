/**
 * FileTypes.ts
 * 
 * This file contains type definitions related to file handling in the application,
 * including metadata, MIME types, filename handling, media properties, and processing status.
 */

/**
 * Represents the basic metadata of a file
 */
export interface FileMetadata {
  /** Unique identifier for the file */
  id: string;
  /** Creation date of the file */
  createdAt: Date;
  /** Last modification date of the file */
  modifiedAt: Date;
  /** Size of the file in bytes */
  size: number;
  /** User who owns or uploaded the file */
  owner?: string;
  /** Additional custom metadata as key-value pairs */
  customMetadata?: Record<string, unknown>;
}

/**
 * Supported MIME type categories in the application
 */
export enum MimeCategory {
  VIDEO = 'video',
  AUDIO = 'audio',
  IMAGE = 'image',
  DOCUMENT = 'document',
  SUBTITLE = 'subtitle',
  XML = 'xml',
  JSON = 'json',
  OTHER = 'other',
}

/**
 * Specific MIME types supported by the application
 */
export enum SupportedMimeType {
  // Video formats
  MP4 = 'video/mp4',
  MOV = 'video/quicktime',
  AVI = 'video/x-msvideo',
  MKV = 'video/x-matroska',
  WEBM = 'video/webm',
  
  // Audio formats
  MP3 = 'audio/mpeg',
  WAV = 'audio/wav',
  AAC = 'audio/aac',
  FLAC = 'audio/flac',
  OGG = 'audio/ogg',
  
  // Image formats
  JPEG = 'image/jpeg',
  PNG = 'image/png',
  GIF = 'image/gif',
  WEBP = 'image/webp',
  
  // Document formats
  PDF = 'application/pdf',
  
  // Subtitle formats
  SRT = 'application/x-subrip',
  VTT = 'text/vtt',
  
  // Data formats
  XML = 'application/xml',
  JSON = 'application/json',
}

/**
 * Interface for MIME type information
 */
export interface MimeTypeInfo {
  /** The full MIME type string (e.g., 'video/mp4') */
  mimeType: string;
  /** The category of the MIME type */
  category: MimeCategory;
  /** Whether this MIME type is supported by the application */
  isSupported: boolean;
  /** File extensions typically associated with this MIME type */
  extensions: string[];
}

/**
 * Represents information about a file's name and extension
 */
export interface FilenameInfo {
  /** The complete filename with extension */
  fullName: string;
  /** The filename without extension */
  baseName: string;
  /** The file extension (without the dot) */
  extension: string;
  /** Whether the filename follows the application's naming conventions */
  isValidName: boolean;
  /** Sanitized version of the filename (if original had invalid characters) */
  sanitizedName?: string;
}

/**
 * Represents the resolution of a video or image
 */
export interface Resolution {
  /** Width in pixels */
  width: number;
  /** Height in pixels */
  height: number;
  /** Aspect ratio (width/height) */
  aspectRatio: number;
}

/**
 * Represents the duration of a media file
 */
export interface MediaDuration {
  /** Duration in seconds */
  seconds: number;
  /** Duration in the format HH:MM:SS.mmm */
  formatted: string;
  /** Duration in frames (for video) */
  frames?: number;
  /** Frame rate (frames per second) for video */
  frameRate?: number;
}

/**
 * Source types for files in the application
 */
export enum FileSourceType {
  /** File uploaded from local storage */
  LOCAL_UPLOAD = 'local_upload',
  /** File imported from cloud storage */
  CLOUD_IMPORT = 'cloud_import',
  /** File recorded directly from camera */
  CAMERA_CAPTURE = 'camera_capture',
  /** File generated by the application */
  GENERATED = 'generated',
  /** File imported from external URL */
  URL_IMPORT = 'url_import',
  /** File shared from another user */
  SHARED = 'shared',
}

/**
 * Processing status of a file
 */
export enum FileProcessingStatus {
  /** File is queued for processing */
  QUEUED = 'queued',
  /** File is currently being processed */
  PROCESSING = 'processing',
  /** File processing completed successfully */
  COMPLETED = 'completed',
  /** File processing failed */
  FAILED = 'failed',
  /** File processing was cancelled */
  CANCELLED = 'cancelled',
}

/**
 * Detailed information about file processing
 */
export interface FileProcessingInfo {
  /** Current status of file processing */
  status: FileProcessingStatus;
  /** Progress percentage (0-100) */
  progress: number;
  /** Start time of processing */
  startedAt?: Date;
  /** Completion time of processing */
  completedAt?: Date;
  /** Error message if processing failed */
  error?: string;
  /** Additional processing details */
  details?: Record<string, unknown>;
}

/**
 * Comprehensive file information combining all aspects
 */
export interface FileInfo {
  /** Basic file metadata */
  metadata: FileMetadata;
  /** MIME type information */
  mimeInfo: MimeTypeInfo;
  /** Filename information */
  filenameInfo: FilenameInfo;
  /** Media duration (for audio/video files) */
  duration?: MediaDuration;
  /** Resolution (for video/image files) */
  resolution?: Resolution;
  /** Source of the file */
  sourceType: FileSourceType;
  /** Processing status and information */
  processing: FileProcessingInfo;
  /** File access URL or path */
  url: string;
  /** Thumbnail URL for media files */
  thumbnailUrl?: string;
  /** Whether the file is currently selected in the UI */
  isSelected?: boolean;
}

/**
 * Type guard to check if a file is a video file
 * @param file The file to check
 * @returns True if the file is a video
 */
export function isVideoFile(file: FileInfo): boolean {
  return file.mimeInfo.category === MimeCategory.VIDEO;
}

/**
 * Type guard to check if a file is an audio file
 * @param file The file to check
 * @returns True if the file is an audio
 */
export function isAudioFile(file: FileInfo): boolean {
  return file.mimeInfo.category === MimeCategory.AUDIO;
}

/**
 * Type guard to check if a file is an image file
 * @param file The file to check
 * @returns True if the file is an image
 */
export function isImageFile(file: FileInfo): boolean {
  return file.mimeInfo.category === MimeCategory.IMAGE;
}

/**
 * Validates if a MIME type is supported by the application
 * @param mimeType The MIME type to validate
 * @returns True if the MIME type is supported
 */
export function isSupportedMimeType(mimeType: string): boolean {
  return Object.values(SupportedMimeType).includes(mimeType as SupportedMimeType);
}

/**
 * Gets the category for a given MIME type
 * @param mimeType The MIME type to categorize
 * @returns The category of the MIME type
 */
export function getMimeCategory(mimeType: string): MimeCategory {
  if (mimeType.startsWith('video/')) return MimeCategory.VIDEO;
  if (mimeType.startsWith('audio/')) return MimeCategory.AUDIO;
  if (mimeType.startsWith('image/')) return MimeCategory.IMAGE;
  if (mimeType === 'application/pdf') return MimeCategory.DOCUMENT;
  if (mimeType === 'application/x-subrip' || mimeType === 'text/vtt') return MimeCategory.SUBTITLE;
  if (mimeType === 'application/xml' || mimeType.endsWith('+xml')) return MimeCategory.XML;
  if (mimeType === 'application/json' || mimeType.endsWith('+json')) return MimeCategory.JSON;
  return MimeCategory.OTHER;
}

/**
 * Parses a filename into its components
 * @param filename The filename to parse
 * @returns Information about the filename
 */
export function parseFilename(filename: string): FilenameInfo {
  const lastDotIndex = filename.lastIndexOf('.');
  const baseName = lastDotIndex > 0 ? filename.substring(0, lastDotIndex) : filename;
  const extension = lastDotIndex > 0 ? filename.substring(lastDotIndex + 1) : '';
  
  // Simple validation - no special characters except dash and underscore
  const isValidName = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9]+$/.test(filename);
  
  return {
    fullName: filename,
    baseName,
    extension,
    isValidName,
    sanitizedName: isValidName ? undefined : filename.replace(/[^a-zA-Z0-9\-_\.]/g, '_')
  };
}

/**
 * Formats duration in seconds to HH:MM:SS.mmm format
 * @param seconds Duration in seconds
 * @returns Formatted duration string
 */
export function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const milliseconds = Math.floor((seconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
}
